<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>Hopac</name></assembly>
<members>
<member name="T:Hopac.BoundedMb`1">
<summary>
 Represents a bounded synchronous mailbox for many to many communication.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Hopac.EmbeddedJobBuilder">
<summary>
 A builder for embedded jobs.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Hopac.EmbeddedJob`1">
<summary>
 Represents a job to be embedded within a computation built upon jobs.
</summary>
</member>
<member name="M:Hopac.IAsyncDisposable.DisposeAsync">
<summary>
 Returns a job that needs to be executed to dispose the resource.  The
 returned job should wait until the resource is properly disposed.
</summary>
</member>
<member name="T:Hopac.IAsyncDisposable">
<summary>
 An experimental interface for asynchronously disposable resources.  See
 also: `usingAsync`.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Hopac.JobBuilder">
<summary>
 Expression builder type for jobs.
</summary>
</member>
<member name="T:Hopac.Void">
<summary>
 A type that has no public constructors to indicate that a job or function
 does not return normally.
</summary>
</member>
<member name="M:Hopac.Alt.paranoid``1(Hopac.Alt{``0})">
<summary>
 Given an alternative, creates a new alternative that behaves exactly like
 the given alternative, except that the new alternative obviously cannot be
 directly downcast to the underlying type of the given alternative.  This
 operation is provided for debugging purposes.  You can always break
 abstractions using reflection.  See also: `Job.paranoid`.
</summary>
</member>
<member name="M:Hopac.Alt.tryFinallyJob``1(Hopac.Alt{``0},Hopac.Job{Microsoft.FSharp.Core.Unit})">
<summary>
 Implements a variation of the `try-finally` exception handling construct
 for alternatives.  The given action, specified as a job, is executed after
 the alternative has been committed to, whether the alternative fails or
 completes successfully.  Note that the action is not executed in case the
 alternative is not committed to.  Use `withNack` to attach the action to
 the non-committed case.
</summary>
</member>
<member name="M:Hopac.Alt.tryFinallyFun``1(Hopac.Alt{``0},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Implements a variation of the `try-finally` exception handling construct
 for alternatives.  The given action, specified as a function, is executed
 after the alternative has been committed to, whether the alternative fails
 or completes successfully.  Note that the action is not executed in case
 the alternative is not committed to.  Use `withNack` to attach the action
 to the non-committed case.
</summary>
</member>
<member name="M:Hopac.Alt.tryIn``4(Hopac.Alt{``0},Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{System.Exception,``3})">
<summary>
 Implements the `try-in-unless` exception handling construct for
 alternatives.  Both of the continuation jobs `&apos;x -&gt; Job&lt;&apos;y&gt;`, for success,
 and `exn -&gt; Job&lt;&apos;y&gt;`, for failure, are invoked from a tail position.

 Exceptions from both before and after the commit point can be handled.  An
 exception that occurs before a commit point, from the user code in a
 `guard`, `delay`, or `withNack`, results in treating that exception as the
 commit point.

 Note you can also use function or job level exception handling before the
 commit point within the user code in a `guard`, `delay`, or `withNack`.
</summary>
</member>
<member name="M:Hopac.Alt.Ignore``1(Hopac.Alt{``0})">
<summary>
 `Ignore xA` is equivalent to `xA |&gt;&gt;? fun _ -&gt; ()`.
</summary>
</member>
<member name="M:Hopac.Alt.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Hopac.Alt{``0})">
<summary>
 `xA |&gt; map x2y` is equivalent to `xA |&gt; wrap (x2y &gt;&gt; result)`.  This is
 the same as `|&gt;&gt;?` with the arguments flipped.
</summary>
</member>
<member name="M:Hopac.Alt.wrap``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Hopac.Alt{``0})">
<summary>
 Creates an alternative whose result is passed to the given job constructor
 and processed with the resulting job after the given alternative has been
 committed to.  This is the same as `&gt;&gt;=?` with the arguments flipped.
</summary>
</member>
<member name="M:Hopac.Alt.chooser``2(System.Collections.Generic.IEnumerable{``0})">
<summary>
 `chooser xAs` is like `choose xAs` except that the order in which the
 alternatives from the sequence are considered will be determined at random
 each time the alternative is used.  See also: `&lt;~&gt;?`.
</summary>
</member>
<member name="M:Hopac.Alt.choose``2(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Creates an alternative that is available when any one of the given
 alternatives is.  See also: `&lt;|&gt;?`.

 Note that `choose []` is equivalent to `never ()`.
</summary>
</member>
<member name="M:Hopac.Alt.wrapAbort``1(Hopac.Job{Microsoft.FSharp.Core.Unit},Hopac.Alt{``0})">
<summary>
 Returns a new alternative that upon picking time makes it so that the
 given job will be started if the given alternative isn&apos;t the one being
 picked.
</summary>
</member>
<member name="M:Hopac.Alt.withNack``3(Microsoft.FSharp.Core.FSharpFunc{Hopac.Promise{Microsoft.FSharp.Core.Unit},``0})">
<summary>
 Creates an alternative that is computed at instantiation time with the
 given job constructed with a negative acknowledgment alternative.  See
 also: `guard`.
</summary>
</member>
<member name="M:Hopac.Alt.random``2(Microsoft.FSharp.Core.FSharpFunc{System.UInt64,``0})">
<summary>
 Creates an alternative that is computed at instantiation time with the
 the given function, which will be called with a pseudo random 64-bit
 unsigned integer.  See also: `Random.bind`.
</summary>
</member>
<member name="M:Hopac.Alt.delay``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 Creates an alternative that is computed at instantiation time with the
 given thunk.

 `delay` is an optimized weaker form of `guard` that can be used when no
 concurrent operations beyond the returned alternative are required by the
 encapsulated request protocol.
</summary>
</member>
<member name="M:Hopac.Alt.guard``2(Hopac.Job{``0})">
<summary>
 Creates an alternative that is computed at instantiation time with the
 given job.  See also: `withNack`.
</summary>
</member>
<member name="M:Hopac.Alt.raises``1(System.Exception)">
<summary>
 Creates an alternative that has the effect of raising the specified
 exception.  `raises e` is equivalent to `delay &lt;| fun () -&gt; raise e`.
</summary>
</member>
<member name="M:Hopac.Alt.once``1(``0)">
<summary>
 Returns an alternative that can be committed to once and that produces the
 given value.
</summary>
</member>
<member name="M:Hopac.Alt.zero">
<summary>
 Returns an alternative that is never available.  `zero ()` is an optimized
 version of `never ()`.
</summary>
</member>
<member name="M:Hopac.Alt.never``1">
<summary>
 Creates an alternative that is never available.

 Note that synchronizing on `never ()`, without other alternatives, is
 equivalent to performing `abort ()`.
</summary>
</member>
<member name="M:Hopac.Alt.unit">
<summary>
 Returns an alternative that is always available and results in the unit
 value.  `unit ()` is an optimized version of `always ()`.
</summary>
</member>
<member name="M:Hopac.Alt.always``1(``0)">
<summary>
 Creates an alternative that is always available and results in the given
 value.

 Note that when there are alternatives immediately available in a choice,
 the first such alternative will be committed to.
</summary>
</member>
<member name="M:Hopac.Alt.Infixes.op_LessPlusGreaterQmark``2(Hopac.Alt{``0},Hopac.Alt{``1})">
<summary>
 An alternative that is equivalent to first picking either one of the
 given alternatives and then picking the other alternative.  Note that
 this is not the same as picking the alternatives in a single
 transaction.  Such an operation would require a more complex
 synchronization protocol like with the so called Transactional Events.
</summary>
</member>
<member name="M:Hopac.Alt.Infixes.op_GreaterGreaterBangQmark``2(Hopac.Alt{``0},System.Exception)">
<summary>
 `xA &gt;&gt;!? e` is equivalent to `xA &gt;&gt;=? fun _ -&gt; raise e`.
</summary>
</member>
<member name="M:Hopac.Alt.Infixes.op_GreaterGreaterPercentQmark``2(Hopac.Alt{``0},``1)">
<summary>
 `xA &gt;&gt;%? y` is equivalent to `xA &gt;&gt;=? fun _ -&gt; result y`.
</summary>
</member>
<member name="M:Hopac.Alt.Infixes.op_BarGreaterGreaterQmark``2(Hopac.Alt{``0},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 `xA |&gt;&gt;? x2y` is equivalent to `xA &gt;&gt;=? (x2y &gt;&gt; result)`.  This is the
 same as `map` with the arguments flipped.
</summary>
</member>
<member name="M:Hopac.Alt.Infixes.op_DotGreaterGreaterQmark``2(Hopac.Alt{``0},Hopac.Job{``1})">
<summary>
 `xA .&gt;&gt;? yJ` is equivalent to `xA &gt;&gt;=? fun x -&gt; yJ &gt;&gt;% x`.
</summary>
</member>
<member name="M:Hopac.Alt.Infixes.op_GreaterGreaterDotQmark``2(Hopac.Alt{``0},Hopac.Job{``1})">
<summary>
 `xA &gt;&gt;.? yJ` is equivalent to `xA &gt;&gt;=? fun _ -&gt; yJ`.
</summary>
</member>
<member name="M:Hopac.Alt.Infixes.op_GreaterGreaterEqualsQmark``3(Hopac.Alt{``0},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Creates an alternative whose result is passed to the given job
 constructor and processed with the resulting job after the given
 alternative has been committed to.  This is the same as `wrap` with the
 arguments flipped.
</summary>
</member>
<member name="M:Hopac.Alt.Infixes.op_LessTwiddleGreaterQmark``1(Hopac.Alt{``0},Hopac.Alt{``0})">
<summary>
 `xA1 &lt;~&gt;? xA2` is like `xA1 &lt;|&gt;? xA2` except that the order in which
 `xA1` and `xA2` are considered is determined at random every time the
 alternative is used.  See also: `chooser`.
</summary>
</member>
<member name="M:Hopac.Alt.Infixes.op_LessBarGreaterQmark``1(Hopac.Alt{``0},Hopac.Alt{``0})">
<summary>
 Creates an alternative that is available when either of the given
 alternatives is available.  `xA1 &lt;|&gt;? xA2` is an optimized version of
 `choose [xA1; xA2]`.
</summary>
</member>
<member name="T:Hopac.Alt.Infixes">
<summary>
 Infix operators on alternatives.  You can open this module to bring all
 of the infix operators into scope.
</summary>
</member>
<member name="T:Hopac.Alt">
<summary>
 Operations on first-class synchronous operations or alternatives.
</summary>
</member>
<member name="M:Hopac.BoundedMb.take``1(Hopac.BoundedMb{``0})">
<summary>
 Selective synchronous operation to take a message from a bounded mailbox.
 `take` operations are processed in FIFO order and become enabled as soon
 as there are messages in the bounded buffer.  If the buffer capacity is
 `0`, `take` behaves exactly like `Ch.take`.
</summary>
</member>
<member name="M:Hopac.BoundedMb.put``1(Hopac.BoundedMb{``0},``0)">
<summary>
 Selective synchronous operation to put a message to a bounded mailbox.
 `put` operations are processed in FIFO order and become enabled as soon as
 there is room in the bounded buffer.  If the buffer capacity is `0`, `put`
 behaves exactly like `Ch.give`.
</summary>
</member>
<member name="M:Hopac.BoundedMb.create``1(System.Int32)">
<summary>
 Returns a job that creates a new bounded mailbox with a buffer of the
 specified maximum capacity.  Note that a bounded mailbox with a capacity
 of `0` behaves exactly the same as a channel, `Ch&lt;_&gt;`.
</summary>
</member>
<member name="T:Hopac.BoundedMb">
<summary>
 Operations on bounded synchronous mailboxes.
</summary>
</member>
<member name="M:Hopac.Ch.send``1(Hopac.Ch{``0},``0)">
<summary>
 Creates a job that sends a value to another job on the given channel.  A
 send operation is asynchronous.  In other words, a send operation does not
 wait for another job to give the value to.
</summary>
</member>
<member name="M:Hopac.Ch.take``1(Hopac.Ch{``0})">
<summary>
 Creates an alternative that, at instantiation time, offers to take a value
 from another job on the given channel, and becomes available when another
 job offers to give a value.
</summary>
</member>
<member name="M:Hopac.Ch.give``1(Hopac.Ch{``0},``0)">
<summary>
 Creates an alternative that, at instantiation time, offers to give the
 given value on the given channel, and becomes available when another job
 offers to take the value.  See also: `&lt;--`.
</summary>
</member>
<member name="M:Hopac.Ch.create``1">
<summary>
 Creates a job that creates a new channel.
</summary>
</member>
<member name="M:Hopac.Ch.Try.take``1(Hopac.Ch{``0})">
<summary>
 Creates a job that attempts to take a value from another job waiting on
 the given channel.  Note that the other side of the communication must
 be blocked on the channel for communication to happen.
</summary>
</member>
<member name="M:Hopac.Ch.Try.give``1(Hopac.Ch{``0},``0)">
<summary>
 Creates a job that attempts to give a value to another job waiting on
 the given channel.  The result indicates whether a value was given or
 not.  Note that the other side of the communication must be blocked on
 the channel for communication to happen.
</summary>
</member>
<member name="T:Hopac.Ch.Try">
<summary>
 Polling, or non-blocking, operations on synchronous channels.
</summary>
</member>
<member name="M:Hopac.Ch.Global.send``1(Hopac.Ch{``0},``0)">
<summary>
 Sends the given value to the specified channel.  `Ch.Global.send xCh x`
 is equivalent to `Ch.send xCh x |&gt; TopLevel.start`.

 Note that using this function in a job workflow is not optimal and you
 should use `Ch.send` instead.
</summary>
</member>
<member name="T:Hopac.Ch.Global">
<summary>
 Operations bound to the global scheduler.
</summary>
</member>
<member name="M:Hopac.Ch.Now.create``1">
<summary>
 Creates a new channel.
</summary>
</member>
<member name="T:Hopac.Ch.Now">
<summary>
 Immediate or non-workflow operations on synchronous channels.
</summary>
</member>
<member name="T:Hopac.Ch">
<summary>
 Operations on synchronous channels.
</summary>
</member>
<member name="M:Hopac.Extensions.Task.startJob.Static``1(Hopac.Job{``0})">
<summary>
 Creates a job that starts the given job as a separate concurrent job,
 whose result can be obtained from the returned task.
</summary>
</member>
<member name="M:Hopac.Extensions.Task.bindJob.Static``2(System.Threading.Tasks.Task,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 `bindJob (uT, u2xJ)` is equivalent to `awaitJob uT &gt;&gt;= u2xJ`.
</summary>
</member>
<member name="M:Hopac.Extensions.Task.bindJob.Static``3(System.Threading.Tasks.Task{``0},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 `bindJob (xT, x2yJ)` is equivalent to `awaitJob xT &gt;&gt;= x2yJ`.
</summary>
</member>
<member name="M:Hopac.Extensions.Task.awaitJob.Static(System.Threading.Tasks.Task)">
<summary>
 Creates a job that waits until the given task finishes.  Note that this
 does not start the task.  Make sure that the task is started correctly.
</summary>
</member>
<member name="M:Hopac.Extensions.Task.awaitJob.Static``1(System.Threading.Tasks.Task{``0})">
<summary>
 Creates a job that waits for the given task to finish and then returns
 the result of the task.  Note that this does not start the task.  Make
 sure that the task is started correctly.
</summary>
</member>
<member name="M:Hopac.Extensions.asyncOn(System.Threading.SynchronizationContext,Hopac.Scheduler)">
<summary>
 Builder for an async operation started on the given synchronization
 context with jobs on the specified scheduler wrapped as a job.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Hopac.Extensions.Async.OnWithSchedulerBuilder">
<summary>
 Builder for async workflows.  The methods in this builder delegate to
 the default `async` builder.
</summary>
</member>
<member name="M:Hopac.Extensions.Async.ofJobOn``1(Hopac.Scheduler,Hopac.Job{``0})">
<summary>
 Creates an async operation that starts the given job on the specified
 scheduler and then waits until the started job finishes.  See also:
 `Job.scheduler`, `Async.Global.ofJob`.
</summary>
</member>
<member name="M:Hopac.Extensions.Async.toAltOn``1(System.Threading.SynchronizationContext,Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Creates an alternative that, when instantiated, posts the given async
 operation to the specified synchronization context for execution and
 then becomes enabled once the operation finishes.  Furthermore, in case
 the alternative is not committed to, the async operation is cancelled.
 As a special case, `toAltOn null xA` is equivalent to `toAlt xA`.  See
 also: `toJob`, `toJobOn`.
</summary>
</member>
<member name="M:Hopac.Extensions.Async.toAlt``1(Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Creates an alternative that, when instantiated, starts the given async
 operation and then becomes enabled once the operation finishes.
 Furthermore, in case the alternative is not committed to, the async
 operation is cancelled.
</summary>
</member>
<member name="M:Hopac.Extensions.Async.toJobOn``1(System.Threading.SynchronizationContext,Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Creates a job that posts the given async operation to the specified
 synchronization context for execution and then waits until the operation
 finishes.  As a special case, `toJobOn null xA` is equivalent to `toJob
 xA`.  See also: `toAlt`, `toAltOn`.
</summary>
</member>
<member name="M:Hopac.Extensions.Async.toJob``1(Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Creates a job that starts the given async operation and then waits until
 the operation finishes.
</summary>
</member>
<member name="M:Hopac.Extensions.Async.Global.ofJob``1(Hopac.Job{``0})">
<summary>
 Creates an async operation that starts the given job on the global
 scheduler and then waits until the started job finishes.  See also:
 `Async.ofJobOn`.
</summary>
</member>
<member name="T:Hopac.Extensions.Async.Global">
<summary>
 Operations on the global scheduler.
</summary>
</member>
<member name="T:Hopac.Extensions.Async">
<summary>
 Operations for interfacing F# async operations with jobs.
</summary>
</member>
<member name="M:Hopac.Extensions.Seq.foldJob``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``0,System.Collections.Generic.IEnumerable{``1})">
<summary>
 Sequentially folds the job constructor over the given sequence and
 returns the result of the fold.
</summary>
</member>
<member name="M:Hopac.Extensions.Seq.mapJob``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Sequentially maps the given job constructor to the elements of the
 sequence and returns a list of the results.
</summary>
</member>
<member name="M:Hopac.Extensions.Seq.iterJobIgnore``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
<summary>
 `iterJobIgnore x2yJ xs` is equivalent to `iterJob (x2yJ &gt;&gt; Job.Ignore)
 xs`.
</summary>
</member>
<member name="M:Hopac.Extensions.Seq.iterJob``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Sequentially iterates the given job constructor over the given sequence.
</summary>
</member>
<member name="M:Hopac.Extensions.Seq.Con.mapJob``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Iterates the given job constructor over the given sequence, runs the
 constructed jobs as separate concurrent jobs and waits until all of
 the jobs have finished collecting the results into a list.
</summary>
</member>
<member name="M:Hopac.Extensions.Seq.Con.iterJobIgnore``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
<summary>
 `iterJobIgnore x2yJ xs` is equivalent to `iterJob (x2yJ &gt;&gt; Job.Ignore)
 xs`.
</summary>
</member>
<member name="M:Hopac.Extensions.Seq.Con.iterJob``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Iterates the given job constructor over the given sequence, runs the
 constructed jobs as separate concurrent jobs and waits until all of
 the jobs have finished.
</summary>
</member>
<member name="T:Hopac.Extensions.Seq.Con">
<summary>
 Operations for processing sequences using concurrent jobs.
</summary>
</member>
<member name="T:Hopac.Extensions.Seq">
<summary>
 Operations for processing sequences with jobs.
</summary>
</member>
<member name="M:Hopac.Extensions.Array.iterJobIgnore``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[])">
<summary>
 `iterJobIgnore x2yJ xs` is equivalent to `iterJob (x2yJ &gt;&gt; Job.Ignore)
 xs`.
</summary>
</member>
<member name="M:Hopac.Extensions.Array.iterJob``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[])">
<summary>
 Sequentially iterates the given job constructor over the given array.
 `Array.iterJob x2uJ xs` is an optimized version of `Seq.iterJob x2uJ
 xs`.
</summary>
</member>
<member name="M:Hopac.Extensions.Array.mapJob``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[])">
<summary>
 Sequentially maps the given job constructor to the elements of the array
 and returns an array of the results.  `Array.mapJob x2yJ xs` is an
 optimized version of `Seq.mapJob x2yJ xs |&gt;&gt; fun ys -&gt; ys.ToArray ()`.
</summary>
</member>
<member name="T:Hopac.Extensions.Array">
<summary>
 Operations for processing arrays with jobs.
</summary>
</member>
<member name="T:Hopac.Extensions">
<summary>
 Extensions to various system modules and types for programming with jobs.
 You can open this module to use the extensions much like as if they were
 part of the existing modules and types.
</summary>
</member>
<member name="M:Hopac.IVar.read``1(Hopac.IVar{``0})">
<summary>
 Creates an alternative that becomes available after the write once
 variable has been written to.
</summary>
</member>
<member name="M:Hopac.IVar.fillFailure``1(Hopac.IVar{``0},System.Exception)">
<summary>
 Creates a job that writes the given exception to the given write once
 variable.  It is an error to write to a single `IVar` more than once.
 This assumption may be used to optimize the implementation and incorrect
 usage leads to undefined behavior.  See also: `&lt;-=!`, `fill`.
</summary>
</member>
<member name="M:Hopac.IVar.tryFill``1(Hopac.IVar{``0},``0)">
<summary>
 Creates a job that tries to write the given value to the given write once
 variable.  No operation takes places and no error is reported in case the
 write once variable has already been written to.
</summary>
</member>
<member name="M:Hopac.IVar.fill``1(Hopac.IVar{``0},``0)">
<summary>
 Creates a job that writes the given value to the given write once
 variable.  It is an error to write to a single write once variable more
 than once.  This assumption may be used to optimize the implementation of
 `fill` and incorrect usage leads to undefined behavior.
</summary>
</member>
<member name="M:Hopac.IVar.create``1">
<summary>
 Creates a job that creates a new write once variable.
</summary>
</member>
<member name="M:Hopac.IVar.Now.get``1(Hopac.IVar{``0})">
<summary>
 Returns the value or raises the failure exception written to the write
 once variable.  It is considered an error if the write once variable has
 not yet been written to.

 This operation is mainly provided for advanced uses of write once
 variables such as when creating more complex data structures that make
 internal use of write once variables.  Using this to poll write once
 variables is not generally a good idea.
</summary>
</member>
<member name="M:Hopac.IVar.Now.isFull``1(Hopac.IVar{``0})">
<summary>
 Returns true iff the given write once variable has already been filled
 (either with a value or with a failure).

 This operation is mainly provided for advanced uses of write once
 variables such as when creating more complex data structures that make
 internal use of write once variables.  Using this to poll write once
 variables is not generally a good idea.
</summary>
</member>
<member name="M:Hopac.IVar.Now.createFailure``1(System.Exception)">
<summary>
 Creates a new write once variable with the given failure exception.
</summary>
</member>
<member name="M:Hopac.IVar.Now.createFull``1(``0)">
<summary>
 Creates a new write once variable with the given value.
</summary>
</member>
<member name="M:Hopac.IVar.Now.create``1">
<summary>
 Creates a new write once variable.
</summary>
</member>
<member name="T:Hopac.IVar.Now">
<summary>
 Immediate or non-workflow operations on write once variables.
</summary>
</member>
<member name="T:Hopac.IVar">
<summary>
 Operations on write once variables.
</summary>
</member>
<member name="M:Hopac.Infixes.op_LessLessMinusPlus``1(Hopac.Mailbox{``0},``0)">
<summary>
 Creates a job that sends the given value to the specified mailbox.  This
 operation never blocks.  `xMb &lt;&lt;-+ x` is equivalent to `Mailbox.send xMb
 x`.
</summary>
</member>
<member name="M:Hopac.Infixes.op_LessLessMinusEquals``1(Hopac.MVar{``0},``0)">
<summary>
 Creates a job that writes the given value to the serialized variable.  It
 is an error to write to a `MVar` that is full.  This assumption may be
 used to optimize the implementation and incorrect usage leads to undefined
 behavior.  `xM &lt;&lt;-= x` is equivalent to `MVar.fill xM x`.
</summary>
</member>
<member name="M:Hopac.Infixes.op_LessMinusEqualsBang``1(Hopac.IVar{``0},System.Exception)">
<summary>
 Creates a job that writes the given exception to the given write once
 variable.  It is an error to write to a single `IVar` more than once.
 This assumption may be used to optimize the implementation and incorrect
 usage leads to undefined behavior.  `xI &lt;-=! e` is equivalent to
 `IVar.fillFailure xI e`.
</summary>
</member>
<member name="M:Hopac.Infixes.op_LessMinusEquals``1(Hopac.IVar{``0},``0)">
<summary>
 Creates a job that writes to the given write once variable.  It is an
 error to write to a single `IVar` more than once.  This assumption may be
 used to optimize the implementation and incorrect usage leads to undefined
 behavior.  `xI &lt;-= x` is equivalent to `IVar.fill xI x`.
</summary>
</member>
<member name="M:Hopac.Infixes.op_LessMinusPlus``1(Hopac.Ch{``0},``0)">
<summary>
 Creates a job that sends a value to another job on the given channel.  A
 send operation is asynchronous.  In other words, a send operation does not
 wait for another job to give the value to.  `xCh &lt;-+ x` is equivalent to
 `Ch.send xCh x`.

 Note that channels have been optimized for synchronous operations; an
 occasional send can be efficient, but when sends are queued, performance
 maybe be significantly worse than with a `Mailbox` optimized for
 buffering.
</summary>
</member>
<member name="M:Hopac.Infixes.op_LessMinusMinus``1(Hopac.Ch{``0},``0)">
<summary>
 Creates an alternative that, at instantiation time, offers to give the
 given value on the given channel, and becomes available when another job
 offers to take the value.  `xCh &lt;-- x` is equivalent to `Ch.give xCh x`.
</summary>
</member>
<member name="T:Hopac.Infixes">
<summary>
 Additional infix operators.  You can open this module to bring all of the
 infix operators into scope.
</summary>
</member>
<member name="M:Hopac.Job.paranoid``1(Hopac.Job{``0})">
<summary>
 Given a job, creates a new job that behaves exactly like the given job,
 except that the new job obviously cannot be directly downcast to the
 underlying type of the given job.  This operation is provided for
 debugging purposes.  You can always break abstractions using reflection.
 See also: `Alt.paranoid`.
</summary>
</member>
<member name="M:Hopac.Job.switchToWorker">
<summary>
 Returns a job that ensures that the immediately following operation will
 be executed on a Hopac worker thread.
</summary>
</member>
<member name="M:Hopac.Job.scheduler">
<summary>
 Returns a job that returns the scheduler under which the job is being run.
 This allows interfacing Hopac with existing asynchronous operations that
 do not fall into a pattern that is already supported explicitly.  See, for
 example, the reference implementation of `fromBeginEnd`.  The key is that
 the job that is suspended for the duration of the asynchronous operation
 can then be resumed on the same scheduler.
</summary>
</member>
<member name="M:Hopac.Job.fromEndBegin``1(Microsoft.FSharp.Core.FSharpFunc{System.IAsyncResult,``0},Microsoft.FSharp.Core.FSharpFunc{System.Tuple{System.AsyncCallback,System.Object},System.IAsyncResult})">
<summary>
 `fromEndBegin doEnd doBegin` is equivalent to `fromBeginEnd doBegin doEnd`.
</summary>
</member>
<member name="M:Hopac.Job.fromBeginEnd``1(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{System.AsyncCallback,System.Object},System.IAsyncResult},Microsoft.FSharp.Core.FSharpFunc{System.IAsyncResult,``0})">
<summary>
 Creates a job that performs the asynchronous operation defined by the
 given pair of begin and end operations.
</summary>
</member>
<member name="M:Hopac.Job.conIgnore``2(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Creates a job that runs all of the jobs as separate concurrent jobs and
 then waits for all of the jobs to finish.  The results of the jobs are
 ignored.
</summary>
</member>
<member name="M:Hopac.Job.conCollect``2(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Creates a job that runs all of the jobs as separate concurrent jobs and
 returns a list of the results.

 Note that when multiple jobs raise exceptions, then the created job raises
 an `AggregateException`.
</summary>
</member>
<member name="M:Hopac.Job.seqIgnore``2(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Creates a job that runs all of the jobs in sequence.  The results of the
 jobs are ignored.  See also: `seqCollect`.
</summary>
</member>
<member name="M:Hopac.Job.seqCollect``2(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Creates a job that runs all of the jobs in sequence and returns a list of
 the results.  See also: `seqIgnore`.
</summary>
</member>
<member name="M:Hopac.Job.iterateServer``2(``0,Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Creates a job that starts a separate server job that indefinitely iterates
 the given job constructor starting with the given value.  `iterateServer x
 x2xJ` is equivalent to `iterate x x2xJ |&gt; server`.
</summary>
</member>
<member name="M:Hopac.Job.foreverServer(Hopac.Job{Microsoft.FSharp.Core.Unit})">
<summary>
 Creates a job that starts a separate server job that repeats the given job
 indefinitely.  `foreverServer xJ` is equivalent to `forever xJ |&gt; server`.
</summary>
</member>
<member name="M:Hopac.Job.iterate``3(``0,Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Creates a job that indefinitely iterates the given job constructor
 starting with the given value.  See also: `iterateServer`, `forever`.
</summary>
</member>
<member name="M:Hopac.Job.foreverIgnore``2(Hopac.Job{``0})">
<summary>
 `foreverIgnore xJ` is equivalent to `Job.Ignore xJ |&gt; forever`.
</summary>
</member>
<member name="M:Hopac.Job.forever``1(Hopac.Job{Microsoft.FSharp.Core.Unit})">
<summary>
 Creates a job that repeats the given job indefinitely.  See also:
 `foreverServer`, `iterate`.
</summary>
</member>
<member name="M:Hopac.Job.whenDo(System.Boolean,Hopac.Job{Microsoft.FSharp.Core.Unit})">
<summary>
 `whenDo b uJ` is equivalent to `if b then uJ else Job.unit ()`.
</summary>
</member>
<member name="M:Hopac.Job.whileDoIgnore``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Boolean},Hopac.Job{``0})">
<summary>
 `whileDoIgnore u2b xJ` is equivalent to `Job.Ignore xJ |&gt; whileDo u2b`.
</summary>
</member>
<member name="M:Hopac.Job.whileDo(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Boolean},Hopac.Job{Microsoft.FSharp.Core.Unit})">
<summary>
 `whileDo u2b uJ` creates a job that sequentially executes the `uJ` job as
 long as `u2b ()` returns `true`.
</summary>
</member>
<member name="M:Hopac.Job.forDownToIgnore``2(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0})">
<summary>
 `forDownToIgnore hi lo i2xJ` is equivalent to `forDownTo hi lo (i2xJ &gt;&gt;
 Job.Ignore)`.
</summary>
</member>
<member name="M:Hopac.Job.forDownTo``1(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0})">
<summary>
 `forDownTo hi lo i2uJ` creates a job that sequentially iterates from `hi`
 to `lo` (inclusive) and calls the given function to construct jobs that
 will be executed.
</summary>
</member>
<member name="M:Hopac.Job.forUpToIgnore``2(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0})">
<summary>
 `forUpToIgnore lo hi i2xJ` is equivalent to `forUpTo lo hi (i2xJ &gt;&gt;
 Job.Ignore)`.
</summary>
</member>
<member name="M:Hopac.Job.forUpTo``1(System.Int32,System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0})">
<summary>
 `forUpTo lo hi i2uJ` creates a job that sequentially iterates from `lo` to
 `hi` (inclusive) and calls the given function to construct jobs that will
 be executed.
</summary>
</member>
<member name="M:Hopac.Job.forNIgnore``1(System.Int32,Hopac.Job{``0})">
<summary>
 `forNIgnore n xJ` is equivalent to `Job.Ignore xJ |&gt; forN n`.
</summary>
</member>
<member name="M:Hopac.Job.forN(System.Int32,Hopac.Job{Microsoft.FSharp.Core.Unit})">
<summary>
 Creates a job that runs the given job sequentially the given number of
 times.
</summary>
</member>
<member name="M:Hopac.Job.catch``1(Hopac.Job{``0})">
<summary>
 Creates a job that runs the given job and results in either the ordinary
 result of the job or the exception raised by the job.
</summary>
</member>
<member name="M:Hopac.Job.usingAsync``3(``0,Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Implements an experimental `use` like construct for asynchronously
 disposable resources.  The `DisposeAsync` method of the asynchronously
 disposable resource is called to construct a job that is later used to
 dispose the resource after the constructed job returns.  See also:
 `abort`, `using`.
</summary>
</member>
<member name="M:Hopac.Job.using``3(``0,Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Implements the `use` construct for jobs.  The `Dispose` method of the
 given disposable object is called after running the job constructed with
 the disposable object.  See also: `abort`, `usingAsync`.
</summary>
</member>
<member name="M:Hopac.Job.tryFinallyJob``1(Hopac.Job{``0},Hopac.Job{Microsoft.FSharp.Core.Unit})">
<summary>
 Implements a variation of the `try-finally` exception handling construct
 for jobs.  The given action, specified as a job, is executed after the job
 has been run, whether it fails or completes successfully.

 Note that the workflow notation of F# does not support this operation.  It
 only supports the weaker `tryFinallyFun` operation.
</summary>
</member>
<member name="M:Hopac.Job.tryFinallyFun``1(Hopac.Job{``0},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Implements a variation of the `try-finally` exception handling construct
 for jobs.  The given action, specified as a function, is executed after
 the job has been run, whether it fails or completes successfully.
</summary>
</member>
<member name="M:Hopac.Job.tryWith``2(Hopac.Job{``0},Microsoft.FSharp.Core.FSharpFunc{System.Exception,``1})">
<summary>
 Implements the try-with exception handling construct for jobs.
</summary>
</member>
<member name="M:Hopac.Job.tryInDelay``5(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0},Microsoft.FSharp.Core.FSharpFunc{``1,``2},Microsoft.FSharp.Core.FSharpFunc{System.Exception,``4})">
<summary>
 `tryInDelay u2xJ x2yJ e2yJ` is equivalent to `tryIn (delay u2xJ) x2yJ
 e2yJ`.
</summary>
</member>
<member name="M:Hopac.Job.tryIn``4(Hopac.Job{``0},Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{System.Exception,``3})">
<summary>
 Implements the `try-in-unless` exception handling construct for jobs.
 Both of the continuation jobs `&apos;x -&gt; Job&lt;&apos;y&gt;`, for success, and `exn -&gt;
 Job&lt;&apos;y&gt;`, for failure, are invoked from a tail position.  See also:
 `tryInDelay`.
</summary>
</member>
<member name="M:Hopac.Job.raises``1(System.Exception)">
<summary>
 Creates a job that has the effect of raising the specified exception.
 `raises e` is equivalent to `Job.delayWith raise e`.
</summary>
</member>
<member name="M:Hopac.Job.abort``1">
<summary>
 Creates a job that immediately terminates the current job.  See also:
 `startWithFinalizer`.
</summary>
</member>
<member name="M:Hopac.Job.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Hopac.Job{``0})">
<summary>
 Creates a job that runs the given job and maps the result of the job with
 the given function.  This is the same as `|&gt;&gt;` with the arguments flipped.
</summary>
</member>
<member name="M:Hopac.Job.join``2(Hopac.Job{``0})">
<summary>
 `join xJJ` is equivalent to `bind id xJJ`.
</summary>
</member>
<member name="M:Hopac.Job.bind``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Hopac.Job{``0})">
<summary>
 Creates a job that first runs the given job and then passes the result of
 that job to the given function to build another job which will then be
 run.  This is the same as `&gt;&gt;=` with the arguments flipped.
</summary>
</member>
<member name="M:Hopac.Job.result``1(``0)">
<summary>
 Creates a job with the given result.
</summary>
</member>
<member name="M:Hopac.Job.unit">
<summary>
 Returns a job that does nothing and returns `()`.  `unit ()` is an
 optimized version of `result ()`.
</summary>
</member>
<member name="M:Hopac.Job.Ignore``1(Hopac.Job{``0})">
<summary>
 `Ignore xJ` is equivalent to `xJ |&gt;&gt; fun _ -&gt; ()`.
</summary>
</member>
<member name="M:Hopac.Job.thunk``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 Creates a job that invokes the given thunk to compute the result of the
 job.  `thunk u2x` is equivalent to `result () |&gt;&gt; u2x`.
</summary>
</member>
<member name="M:Hopac.Job.lift``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0)">
<summary>
 Creates a job that calls the given function with the given value to
 compute the result of the job.  `lift x2y x` is equivalent to `result x
 |&gt;&gt; x2y`.
</summary>
</member>
<member name="M:Hopac.Job.delayWith``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0)">
<summary>
 Creates a job that calls the given function with the given value to build
 a job that will then be run.  `delayWith x2yJ x` is equivalent to `result
 x &gt;&gt;= x2yJ`.
</summary>
</member>
<member name="M:Hopac.Job.delay``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 Creates a job that calls the given function to build a job that will then
 be run.  `delay u2xJ` is equivalent to `result () &gt;&gt;= u2xJ`.
</summary>
</member>
<member name="M:Hopac.Job.startWithFinalizerIgnore``1(Hopac.Job{Microsoft.FSharp.Core.Unit},Hopac.Job{``0})">
<summary>
 `startWithFinalizerIgnore finalizerJ xJ` is equivalent to `Job.Ignore xJ
 |&gt; startWithFinalizer finalizerJ`.
</summary>
</member>
<member name="M:Hopac.Job.startWithFinalizer(Hopac.Job{Microsoft.FSharp.Core.Unit},Hopac.Job{Microsoft.FSharp.Core.Unit})">
<summary>
 `Job.startWithFinalizer finalizerJ uJ` is like `Job.start uJ`, but
 attaches a finalizer to the started job.  The finalizer job is started as
 a separate job in case the started job does not return succesfully or
 raise an exception and is garbage collected.  If the job either returns
 normally or raises an exception, the finalizer job is not started.  See
 also: `Proc`.
</summary>
</member>
<member name="M:Hopac.Job.server(Hopac.Job{Hopac.Void})">
<summary>
 Like `Job.start`, but the given job is known never to return normally, so
 the job can be spawned in an even more lightweight manner.
</summary>
</member>
<member name="M:Hopac.Job.queueIgnore``1(Hopac.Job{``0})">
<summary>
 `queueIgnore xJ` is equivalent to `Job.Ignore xJ |&gt; queue`.
</summary>
</member>
<member name="M:Hopac.Job.queue(Hopac.Job{Microsoft.FSharp.Core.Unit})">
<summary>
 Creates a job that schedules the given job to be run as a separate
 concurrent job.  Use `Promise.queue` if you need to be able to get the
 result.  See also: `Proc.queue`.
</summary>
</member>
<member name="M:Hopac.Job.startIgnore``1(Hopac.Job{``0})">
<summary>
 `startIgnore xJ` is equivalent to `Job.Ignore xJ |&gt; start`.
</summary>
</member>
<member name="M:Hopac.Job.start(Hopac.Job{Microsoft.FSharp.Core.Unit})">
<summary>
 Creates a job that immediately starts running the given job as a separate
 concurrent job.  Use `Promise.start` if you need to be able to get the
 result.  Use `Job.server` if the job never returns normally.  See also:
 `Job.queue`, `Proc.start`.
</summary>
</member>
<member name="M:Hopac.Job.Random.get">
<summary>
 Returns a job that generates a pseudo random 64-bit unsigned integer.
</summary>
</member>
<member name="M:Hopac.Job.Random.map``1(Microsoft.FSharp.Core.FSharpFunc{System.UInt64,``0})">
<summary>
 `map r2x` is equivalent to `bind (r2x &gt;&gt; result)`.
</summary>
</member>
<member name="M:Hopac.Job.Random.bind``2(Microsoft.FSharp.Core.FSharpFunc{System.UInt64,``0})">
<summary>
 `bind r2xJ` creates a job that calls the given job constructor with a
 pseudo random 64-bit unsigned integer.
</summary>
</member>
<member name="T:Hopac.Job.Random">
<summary>
 Operations on the built-in pseudo random number generator (PRNG) of Hopac.
</summary>
</member>
<member name="M:Hopac.Job.Infixes.op_LessMultiplyGreater``2(Hopac.Job{``0},Hopac.Job{``1})">
<summary>
 Creates a job that either runs the given jobs sequentially, like `&lt;&amp;&gt;`,
 or as two separate parallel jobs and returns a pair of their results.

 Note that when the jobs are run in parallel and both of them raise an
 exception then the created job raises an `AggregateException`.
</summary>
</member>
<member name="M:Hopac.Job.Infixes.op_LessAmpGreater``2(Hopac.Job{``0},Hopac.Job{``1})">
<summary>
 Creates a job that runs the given two jobs and then returns a pair of
 their results.  `xJ &lt;&amp;&gt; yJ` is equivalent to `xJ &gt;&gt;= fun x -&gt; yJ &gt;&gt;= fun
 y -&gt; result (x, y)`.
</summary>
</member>
<member name="M:Hopac.Job.Infixes.op_GreaterGreaterBang``2(Hopac.Job{``0},System.Exception)">
<summary>
 Creates a job that runs the given job and then raises the given
 exception.  `xJ &gt;&gt;! e` is equivalent to `xJ &gt;&gt;= fun _ -&gt; raise e`.
</summary>
</member>
<member name="M:Hopac.Job.Infixes.op_GreaterGreaterPercent``2(Hopac.Job{``0},``1)">
<summary>
 Creates a job that runs the given job and then returns the given value.
 `xJ &gt;&gt;% y` is an optimized version of `xJ &gt;&gt;= fun _ -&gt; result y`.
</summary>
</member>
<member name="M:Hopac.Job.Infixes.op_BarGreaterGreater``2(Hopac.Job{``0},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Creates a job that runs the given job and maps the result of the job
 with the given function.  `xJ |&gt;&gt; x2y` is an optimized version of `xJ
 &gt;&gt;= (x2y &gt;&gt; result)`.  This is the same as `map` with the arguments
 flipped.
</summary>
</member>
<member name="M:Hopac.Job.Infixes.op_DotGreaterGreater``2(Hopac.Job{``0},Hopac.Job{``1})">
<summary>
 Creates a job that runs the given two jobs and returns the result of the
 first job.  `xJ .&gt;&gt; yJ` is equivalent to `xJ &gt;&gt;= fun x -&gt; yJ &gt;&gt;% x`.
</summary>
</member>
<member name="M:Hopac.Job.Infixes.op_GreaterGreaterDot``2(Hopac.Job{``0},Hopac.Job{``1})">
<summary>
 Creates a job that runs the given two jobs and returns the result of the
 second job.  `xJ &gt;&gt;. yJ` is equivalent to `xJ &gt;&gt;= fun _ -&gt; yJ`.
</summary>
</member>
<member name="M:Hopac.Job.Infixes.op_GreaterGreaterEquals``3(Hopac.Job{``0},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Creates a job that first runs the given job and then passes the result
 of that job to the given function to build another job which will then
 be run.  This is the same as `bind` with the arguments flipped.
</summary>
</member>
<member name="T:Hopac.Job.Infixes">
<summary>
 Infix operators on jobs.  You can open this module to bring all of the
 infix operators into scope.
</summary>
</member>
<member name="M:Hopac.Job.Global.run``1(Hopac.Job{``0})">
<summary>
 Starts running the given job on the global scheduler and then blocks the
 current thread waiting for the job to either return successfully or
 fail.
</summary>
</member>
<member name="M:Hopac.Job.Global.server(Hopac.Job{Hopac.Void})">
<summary>
 Like `Job.Global.start`, but the given job is known never to return
 normally, so the job can be spawned in an even more lightweight manner.

 Note that using this function in a job workflow is not optimal and you
 should use `Job.server` instead.
</summary>
</member>
<member name="M:Hopac.Job.Global.queueIgnore``1(Hopac.Job{``0})">
<summary>
 `queueIgnore xJ` is equivalent to `Job.Ignore xJ |&gt; queue`.
</summary>
</member>
<member name="M:Hopac.Job.Global.queue(Hopac.Job{Microsoft.FSharp.Core.Unit})">
<summary>
 Queues the job for execution on the global scheduler.

 Note that using this function in a job workflow is not optimal and you
 should use `Job.queue` instead.
</summary>
</member>
<member name="M:Hopac.Job.Global.startIgnore``1(Hopac.Job{``0})">
<summary>
 `startIgnore xJ` is equivalent to `Job.Ignore xJ |&gt; start`.
</summary>
</member>
<member name="M:Hopac.Job.Global.start(Hopac.Job{Microsoft.FSharp.Core.Unit})">
<summary>
 Starts running the given job on the global scheduler, but does not wait
 for the job to finish.

 Note that using this function in a job workflow is not optimal and you
 should use `Job.start` instead.
</summary>
</member>
<member name="M:Hopac.Job.Global.startWithActions``1(Microsoft.FSharp.Core.FSharpFunc{System.Exception,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},Hopac.Job{``0})">
<summary>
 Starts running the given job on the global scheduler, but does not wait
 for the job to finish.  Upon the failure or success of the job, one of
 the given actions is called once.  See also: `abort`.

 Note that using this function in a job workflow is not optimal and you
 should instead use `Job.start` with the desired exception handling
 construct (e.g. `Job.tryIn` or `Job.catch`).
</summary>
</member>
<member name="T:Hopac.Job.Global">
<summary>
 Operations on the global scheduler.

 Note that in a typical program there should only be a few points (maybe
 just one) where jobs are started or run outside of job workflows.
</summary>
</member>
<member name="T:Hopac.Job">
<summary>
 Operations on jobs.
</summary>
</member>
<member name="M:Hopac.Latch.await(Hopac.Latch)">
<summary>
 Returns an alternative that becomes available once the latch opens.
</summary>
</member>
<member name="M:Hopac.Latch.decrement(Hopac.Latch)">
<summary>
 Returns a job that explicitly decrements the counter of the latch.  When
 the counter reaches `0`, the latch becomes open and operations awaiting
 the latch are resumed.
</summary>
</member>
<member name="M:Hopac.Latch.queueAsPromise``1(Hopac.Latch,Hopac.Job{``0})">
<summary>
 Creates a job that queues the given job to run as a separate concurrent
 job and holds the latch until the queued job either returns or fails with
 an exception.  A promise is returned for observing the result or failure
 of the queued job.
</summary>
</member>
<member name="M:Hopac.Latch.queue(Hopac.Latch,Hopac.Job{Microsoft.FSharp.Core.Unit})">
<summary>
 Creates a job that queues the given job to run as a separate concurrent
 job and holds the latch until the queued job either returns or fails with
 an exception.  See also `Latch.queueAsAlt`.
</summary>
</member>
<member name="M:Hopac.Latch.holding``1(Hopac.Latch,Hopac.Job{``0})">
<summary>
 Creates a job that runs the given job holding the specified latch.  Note
 that the latch is only held while the given job is being run.  See also
 `Latch.queue`.
</summary>
</member>
<member name="M:Hopac.Latch.within``2(Microsoft.FSharp.Core.FSharpFunc{Hopac.Latch,``0})">
<summary>
 Creates a job that creates a new latch, passes it to the given function to
 create a new job to run and then awaits for the latch to open.
</summary>
</member>
<member name="M:Hopac.Latch.Now.increment(Hopac.Latch)">
<summary>
 Increments the counter of the latch.
</summary>
</member>
<member name="M:Hopac.Latch.Now.create(System.Int32)">
<summary>
 Creates a new latch with the specified initial count.
</summary>
</member>
<member name="T:Hopac.Latch.Now">
<summary>
 Immediate operations on latches.
</summary>
</member>
<member name="T:Hopac.Latch">
<summary>
 Operations on latches.
</summary>
</member>
<member name="M:Hopac.Lock.duringJob``1(Hopac.Lock,Hopac.Job{``0})">
<summary>
 Creates a job that runs the given job so that the lock is held during the
 execution of the given job.
</summary>
</member>
<member name="M:Hopac.Lock.duringFun``1(Hopac.Lock,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 Creates a job that calls the given function so that the lock is held
 during the execution of the function.
</summary>
</member>
<member name="M:Hopac.Lock.create">
<summary>
 Creates a job that creates a new mutual exclusion lock.
</summary>
</member>
<member name="M:Hopac.Lock.Now.create">
<summary>
 Creates a new lock.
</summary>
</member>
<member name="T:Hopac.Lock.Now">
<summary>
 Immediate or non-workflow operations on locks.
</summary>
</member>
<member name="T:Hopac.Lock">
<summary>
 Operations on mutual exclusion locks.
</summary>
</member>
<member name="M:Hopac.MVar.take``1(Hopac.MVar{``0})">
<summary>
 Creates an alternative that becomes available when the variable contains a
 value and, if committed to, takes the value from the variable.
</summary>
</member>
<member name="M:Hopac.MVar.read``1(Hopac.MVar{``0})">
<summary>
 Creates an alternative that becomes available when the variable contains a
 value and, if committed to, read the value from the variable.
</summary>
</member>
<member name="M:Hopac.MVar.modifyJob``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Hopac.MVar{``0})">
<summary>
 Creates an alternative that takes the value of the serialized variable and
 then fills the variable with the result of performing the given job.

 Note that this operation is not atomic as such.  However, it is a common
 programming pattern to make it so that only the job that has emptied an
 `MVar` by taking a value from it is allowed to fill the `MVar`.  Such an
 access pattern makes operations on the `MVar` appear as atomic.
</summary>
</member>
<member name="M:Hopac.MVar.modifyFun``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Tuple{``0,``1}},Hopac.MVar{``0})">
<summary>
 Creates an alternative that takes the value of the serialized variable and
 then fills the variable with the result of performing the given function.

 Note that this operation is not atomic as such.  However, it is a common
 programming pattern to make it so that only the job that has emptied an
 `MVar` by taking a value from it is allowed to fill the `MVar`.  Such an
 access pattern makes operations on the `MVar` appear as atomic.
</summary>
</member>
<member name="M:Hopac.MVar.fill``1(Hopac.MVar{``0},``0)">
<summary>
 Creates a job that writes the given value to the serialized variable.  It
 is an error to write to a `MVar` that is full.  This assumption may be
 used to optimize the implementation and incorrect usage leads to undefined
 behavior.  See also: `&lt;&lt;-=`.
</summary>
</member>
<member name="M:Hopac.MVar.createFull``1(``0)">
<summary>
 Creates a job that creates a new serialized variable that initially
 contains the given value.
</summary>
</member>
<member name="M:Hopac.MVar.create``1">
<summary>
 Creates a job that creates a new serialized variable that is initially
 empty.
</summary>
</member>
<member name="M:Hopac.MVar.Now.createFull``1(``0)">
<summary>
 Creates a new serialized variable that initially contains the given
 value.
</summary>
</member>
<member name="M:Hopac.MVar.Now.create``1">
<summary>
 Creates a new serialized variable that is initially empty.
</summary>
</member>
<member name="T:Hopac.MVar.Now">
<summary>
 Immediate or non-workflow operations on serialized variables.
</summary>
</member>
<member name="T:Hopac.MVar">
<summary>
 Operations on serialized variables.
</summary>
</member>
<member name="M:Hopac.Mailbox.take``1(Hopac.Mailbox{``0})">
<summary>
 Creates an alternative that becomes available when the mailbox contains at
 least one value and, if committed to, takes a value from the mailbox.
</summary>
</member>
<member name="M:Hopac.Mailbox.send``1(Hopac.Mailbox{``0},``0)">
<summary>
 Creates a job that sends the given value to the specified mailbox.  This
 operation never blocks.  See also: `&lt;&lt;-+`.
</summary>
</member>
<member name="M:Hopac.Mailbox.create``1">
<summary>
 Creates a job that creates a new mailbox.
</summary>
</member>
<member name="M:Hopac.Mailbox.Global.send``1(Hopac.Mailbox{``0},``0)">
<summary>
 Sends the given value to the specified mailbox.  `Mailbox.Global.send
 xMb x` is equivalent to `Mailbox.send xMb x |&gt; TopLevel.start`.

 Note that using this function in a job workflow is not optimal and you
 should use `Mailbox.send` instead.
</summary>
</member>
<member name="T:Hopac.Mailbox.Global">
<summary>
 Operations bound to the global scheduler.
</summary>
</member>
<member name="M:Hopac.Mailbox.Now.create``1">
<summary>
 Creates a new mailbox.
</summary>
</member>
<member name="T:Hopac.Mailbox.Now">
<summary>
 Immediate or non-workflow operations on buffered mailboxes.
</summary>
</member>
<member name="T:Hopac.Mailbox">
<summary>
 Operations on buffered mailboxes.
</summary>
</member>
<member name="M:Hopac.Proc.join(Hopac.Proc)">
<summary>
 Returns an alternative that becomes available once the process is known to
 have been terminated for any reason.
</summary>
</member>
<member name="M:Hopac.Proc.self">
<summary>
 Returns a job that returns the current process.
</summary>
</member>
<member name="M:Hopac.Proc.queueIgnore``1(Hopac.Job{``0})">
<summary>
 `queueIgnore xJ` is equivalent to `Job.Ignore xJ |&gt; queue`.
</summary>
</member>
<member name="M:Hopac.Proc.queue(Hopac.Job{Microsoft.FSharp.Core.Unit})">
<summary>
 Creates a job that queues a new process.  See also: `start`, `Job.queue`.
</summary>
</member>
<member name="M:Hopac.Proc.startIgnore``1(Hopac.Job{``0})">
<summary>
 `startIgnore xJ` is equivalent to `Job.Ignore xJ |&gt; start`.
</summary>
</member>
<member name="M:Hopac.Proc.start(Hopac.Job{Microsoft.FSharp.Core.Unit})">
<summary>
 Creates a job that starts a new process.  See also: `queue`, `Job.start`.
</summary>
</member>
<member name="T:Hopac.Proc">
<summary>
 Operations on processes.
</summary>
</member>
<member name="M:Hopac.Promise.read``1(Hopac.Promise{``0})">
<summary>
 Creates an alternative for reading the promise.  If the promise was
 delayed, it is started as a separate job.
</summary>
</member>
<member name="M:Hopac.Promise.queue``1(Hopac.Job{``0})">
<summary>
 Creates a job that creates a promise, whose value is computed with the
 given job, which is scheduled to be run as a separate concurrent job.  See
 also: `start`, `Job.queue`.
</summary>
</member>
<member name="M:Hopac.Promise.start``1(Hopac.Job{``0})">
<summary>
 Creates a job that creates a promise, whose value is computed with the
 given job, which is immediately started to run as a separate concurrent
 job.  See also: `queue`, `Job.queue`.
</summary>
</member>
<member name="M:Hopac.Promise.Infixes.op_GreaterGreaterBangMultiply``2(Hopac.Job{``0},System.Exception)">
<summary>
 A memoizing version of `&gt;&gt;!`.
</summary>
</member>
<member name="M:Hopac.Promise.Infixes.op_GreaterGreaterPercentMultiply``2(Hopac.Job{``0},``1)">
<summary>
 A memoizing version of `&gt;&gt;%`.
</summary>
</member>
<member name="M:Hopac.Promise.Infixes.op_BarGreaterGreaterMultiply``2(Hopac.Job{``0},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 A memoizing version of `|&gt;&gt;`.
</summary>
</member>
<member name="M:Hopac.Promise.Infixes.op_DotGreaterGreaterMultiply``2(Hopac.Job{``0},Hopac.Job{``1})">
<summary>
 A memoizing version of `.&gt;&gt;`.
</summary>
</member>
<member name="M:Hopac.Promise.Infixes.op_GreaterGreaterDotMultiply``2(Hopac.Job{``0},Hopac.Job{``1})">
<summary>
 A memoizing version of `&gt;&gt;.`.
</summary>
</member>
<member name="M:Hopac.Promise.Infixes.op_GreaterGreaterEqualsMultiply``3(Hopac.Job{``0},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 A memoizing version of `&gt;&gt;=`.
</summary>
</member>
<member name="M:Hopac.Promise.Infixes.op_LessBarGreaterMultiply``1(Hopac.Alt{``0},Hopac.Alt{``0})">
<summary>
 A memoizing version of `&lt;|&gt;?`.
</summary>
</member>
<member name="T:Hopac.Promise.Infixes">
<summary>
 Infix operators on promises.  You can open this module to bring all of
 the infix operators into scope.
</summary>
</member>
<member name="M:Hopac.Promise.Now.get``1(Hopac.Promise{``0})">
<summary>
 Returns the value or raises the failure exception that the promise has
 been fulfilled with.  It is considered an error if the promise has not
 yet been fulfilled.

 This operation is mainly provided for advanced uses of promises such as
 when creating more complex data structures that make internal use of
 promises.  Using this to poll promises is not generally a good idea.
</summary>
</member>
<member name="M:Hopac.Promise.Now.isFulfilled``1(Hopac.Promise{``0})">
<summary>
 Returns true iff the given promise has already been fulfilled (either
 with a value or with a failure).

 This operation is mainly provided for advanced uses of promises such as
 when creating more complex data structures that make internal use of
 promises.  Using this to poll promises is not generally a good idea.
</summary>
</member>
<member name="M:Hopac.Promise.Now.withFailure``1(System.Exception)">
<summary>
 Creates a promise with the given failure exception.
</summary>
</member>
<member name="M:Hopac.Promise.Now.withValue``1(``0)">
<summary>
 Creates a promise with the given value.
</summary>
</member>
<member name="M:Hopac.Promise.Now.delay``1(Hopac.Job{``0})">
<summary>
 Creates a promise whose value is computed lazily with the given job when
 an attempt is made to read the promise.  Although the job is not started
 immediately, the effect is that the delayed job will be run as a
 separate job, which means it is possible to communicate with it as long
 the delayed job is started before trying to communicate with it.
</summary>
</member>
<member name="T:Hopac.Promise.Now">
<summary>
 Immediate or non-workflow operations on promises.
</summary>
</member>
<member name="T:Hopac.Promise">
<summary>
 Operations on promises.
</summary>
</member>
<member name="P:Hopac.Scheduler.Create.TopLevelHandler">
<summary>
 Specifies the top level exception handler job constructor of the
 scheduler.  When a job fails with an otherwise unhandled exception,
 the job is killed and a new job is constructed with the top level
 handler constructor and then started.  To avoid infinite loops, in
 case the top level handler job raises exceptions, it is simply killed
 after printing a message to the console.  The default top level
 handler simply prints out a message to the console.
</summary>
</member>
<member name="P:Hopac.Scheduler.Create.NumWorkers">
<summary>
 Number of worker threads.  Using more than
 `Environment.ProcessorCount` is not optimal and may, in some cases,
 significantly reduce performance.  The default is
 `Environment.ProcessorCount`.
</summary>
</member>
<member name="P:Hopac.Scheduler.Create.MaxStackSize">
<summary>
 Specifies the maximum stack size for worker threads.  The default
 is to use the default maximum stack size of the `Thread` class.
</summary>
</member>
<member name="P:Hopac.Scheduler.Create.IdleHandler">
<summary>
 Specifies the idle handler for workers.  The worker idle handler is
 run whenever an individual worker runs out of work.  The idle handler
 must return an integer value that specifies how many milliseconds the
 worker is allowed to sleep.  `Timeout.Infinite` puts the worker into
 sleep until the scheduler explicitly wakes it up.  `0` means that the
 idle handler found some new work and the worker should immediately
 look for it.
</summary>
</member>
<member name="P:Hopac.Scheduler.Create.Foreground">
<summary>
 Specifies whether worker threads are run as background threads or as
 foreground threads.  The default is to run workers as background
 threads.  If you want to run worker threads as foreground threads,
 then you will have to explicitly kill the worker threads.  Using
 foreground threads is probably preferable if your application
 dynamically creates and kills local schedulers to make sure the
 worker threads are properly killed.
</summary>
</member>
<member name="P:Hopac.Scheduler.Create.Def">
<summary>
 Default options.
</summary>
</member>
<member name="T:Hopac.Scheduler.Create">
<summary>
 A record of scheduler configuration options.
</summary>
</member>
<member name="M:Hopac.Scheduler.kill(Hopac.Scheduler)">
<summary>
 Kills the worker threads of the scheduler one-by-one.  This should only be
 used with a local scheduler that is known to be idle.
</summary>
</member>
<member name="M:Hopac.Scheduler.wait(Hopac.Scheduler)">
<summary>
 Waits until the scheduler becomes completely idle.

 Note that for this to make sense, the scheduler should be a local
 scheduler that your program manages explicitly.
</summary>
</member>
<member name="M:Hopac.Scheduler.server(Hopac.Scheduler,Hopac.Job{Hopac.Void})">
<summary>
 Like `Scheduler.start`, but the given job is known never to return
 normally, so the job can be spawned in an even more lightweight manner.
</summary>
</member>
<member name="M:Hopac.Scheduler.queueIgnore``1(Hopac.Scheduler,Hopac.Job{``0})">
<summary>
 `queueIgnore xJ` is equivalent to `Job.Ignore xJ |&gt; queue`.
</summary>
</member>
<member name="M:Hopac.Scheduler.queue(Hopac.Scheduler,Hopac.Job{Microsoft.FSharp.Core.Unit})">
<summary>
 Queues the given job for execution on the scheduler.

 Note that using this function in a job workflow is not optimal and you
 should use `Job.queue` instead.
</summary>
</member>
<member name="M:Hopac.Scheduler.startIgnore``1(Hopac.Scheduler,Hopac.Job{``0})">
<summary>
 `startIgnore xJ` is equivalent to `Job.Ignore xJ |&gt; start`.
</summary>
</member>
<member name="M:Hopac.Scheduler.start(Hopac.Scheduler,Hopac.Job{Microsoft.FSharp.Core.Unit})">
<summary>
 Starts running the given job, but does not wait for the job to finish.

 Note that using this function in a job workflow is not optimal and you
 should use `Job.start` instead.
</summary>
</member>
<member name="M:Hopac.Scheduler.startWithActions``1(Hopac.Scheduler,Microsoft.FSharp.Core.FSharpFunc{System.Exception,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},Hopac.Job{``0})">
<summary>
 Starts running the given job, but does not wait for the job to finish.
 Upon the failure or success of the job, one of the given actions is called
 once.  See also: `abort`.

 Note that using this function in a job workflow is not optimal and you
 should instead use `Job.start` with desired Job exception handling
 construct (e.g. `Job.tryIn` or `Job.catch`).
</summary>
</member>
<member name="M:Hopac.Scheduler.create(Hopac.Scheduler.Create)">
<summary>
 Creates a new local scheduler.

 Note that a local scheduler does not automatically implement services such
 as the global wall-clock timer.
</summary>
</member>
<member name="M:Hopac.Scheduler.Global.setCreate(Hopac.Scheduler.Create)">
<summary>
 Sets options for creating the global scheduler.  This must be called
 before invoking any Hopac functionality that implicitly creates the
 global scheduler.
</summary>
</member>
<member name="T:Hopac.Scheduler.Global">
<summary>
 Operations on the global scheduler.
</summary>
</member>
<member name="T:Hopac.Scheduler">
<summary>
 Operations on schedulers.  Use of this module requires more intimate
 knowledge of Hopac, but may allow adapting Hopac to special application
 requirements.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Hopac.Stream.Builder">
<summary>
 An experimental generic builder for streams.  The abstract `Join`
 operation needs to be implemented in a derived class.  The `Join`
 operation is then used to implement `Bind`, `Combine`, `For` and `While`
 to get a builder with consistent semantics.
</summary>
</member>
<member name="T:Hopac.Stream.Var`1">
<summary>
 Represents a mutable variable, called a stream variable, that generates a
 stream of values as a side-effect.
</summary>
</member>
<member name="T:Hopac.Stream.Src`1">
<summary>
 Represents an imperative source of a stream of values called a stream
 source.
</summary>
</member>
<member name="T:Hopac.Stream.Stream`1">
<summary>
 Represents a non-deterministic stream of values called a choice stream.
</summary>
</member>
<member name="T:Hopac.Stream.Cons`1.Nil">
<summary>
 Communicates the end of the stream.
</summary>
</member>
<member name="T:Hopac.Stream.Cons`1.Cons">
<summary>
 Communicates a value and the remainder of the stream.
</summary>
</member>
<member name="T:Hopac.Stream.Cons`1">
<summary>
 Represents a point in a non-deterministic stream of values.
</summary>
</member>
<member name="P:Hopac.Stream.switched">
<summary>
 This builder joins substreams with `switch` to produce a stream with the
 latest results.
</summary>
</member>
<member name="P:Hopac.Stream.merged">
<summary>
 This builder joins substreams with `merge` to produce a stream with all
 results in completion order.
</summary>
</member>
<member name="P:Hopac.Stream.appended">
<summary>
 This builder joins substreams with `append` to produce a stream with all
 results in sequential order.
</summary>
</member>
<member name="P:Hopac.Stream.ambed">
<summary>
 This builder joins substreams with `amb` to produce a stream with the
 first results.
</summary>
</member>
<member name="M:Hopac.Stream.inits``1(Hopac.Alt{Hopac.Stream.Cons{``0}})">
<summary>
 Returns a stream of all initial segments of the given stream from shortest
 to longest.
</summary>
</member>
<member name="M:Hopac.Stream.init``1(Hopac.Alt{Hopac.Stream.Cons{``0}})">
<summary>
 Returns a stream with all the elements of the given stream except the last
 element.  If the stream is closed, a closed stream is returned.  Note that
 `append (init xs) (last xs)` is equivalent to `xs`.
</summary>
</member>
<member name="M:Hopac.Stream.last``1(Hopac.Alt{Hopac.Stream.Cons{``0}})">
<summary>
 Returns a stream containing the last element of the given stream.  If the
 given stream is closed, a closed stream is returned.  Note that `append
 (init xs) (last xs)` is equivalent to `xs`.
</summary>
</member>
<member name="M:Hopac.Stream.tails``1(Hopac.Alt{Hopac.Stream.Cons{``0}})">
<summary>
 Returns a stream of all final segments of the given stream from longest to
 shortest.
</summary>
</member>
<member name="M:Hopac.Stream.tail``1(Hopac.Alt{Hopac.Stream.Cons{``0}})">
<summary>
 Returns a stream just like the given stream except without the first
 element.  If the given stream is closed, the result stream will also be
 closed.  Note that `append (head xs) (tail xs)` is equivalent to `xs`.
</summary>
</member>
<member name="M:Hopac.Stream.head``1(Hopac.Alt{Hopac.Stream.Cons{``0}})">
<summary>
 Returns a stream containing only the first element of the given stream.
 If the given stream is closed, the result stream will also be closed.
 Note that `append (head xs) (tail xs)` is equivalent to `xs`.
</summary>
</member>
<member name="M:Hopac.Stream.count``1(Hopac.Alt{Hopac.Stream.Cons{``0}})">
<summary>
 Returns a job that computes the length of the given stream.
</summary>
</member>
<member name="M:Hopac.Stream.iter``1(Hopac.Alt{Hopac.Stream.Cons{``0}})">
<summary>
 Returns a job that iterates over all the elements of the given stream.
 `iter xs` is equivalent to `iterFun id xs`.
</summary>
</member>
<member name="M:Hopac.Stream.iterFun``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},Hopac.Alt{Hopac.Stream.Cons{``0}})">
<summary>
 Returns a job that iterates the given function over the given stream.  See
 also: `iterJob`.
</summary>
</member>
<member name="M:Hopac.Stream.iterJob``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Hopac.Alt{Hopac.Stream.Cons{``0}})">
<summary>
 Returns a job that iterates the given job constructor over the given
 stream.
</summary>
</member>
<member name="M:Hopac.Stream.foldFromFun``2(``0,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},Hopac.Alt{Hopac.Stream.Cons{``1}})">
<summary>
 `foldFromFun s sx2s xs` is equivalent to `foldFun sx2s s xs` and is often
 syntactically more convenient to use.
</summary>
</member>
<member name="M:Hopac.Stream.foldFromJob``3(``0,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Hopac.Alt{Hopac.Stream.Cons{``1}})">
<summary>
 `foldFromJob s sx2sJ xs` is equivalent to `foldJob sx2sJ s xs` and is
 often syntactically more convenient to use.
</summary>
</member>
<member name="M:Hopac.Stream.foldFun``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,Hopac.Alt{Hopac.Stream.Cons{``1}})">
<summary>
 Preliminary and subject to change.
</summary>
</member>
<member name="M:Hopac.Stream.foldJob``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``0,Hopac.Alt{Hopac.Stream.Cons{``1}})">
<summary>
 Preliminary and subject to change.
</summary>
</member>
<member name="M:Hopac.Stream.values``1(Hopac.Alt{Hopac.Stream.Cons{``0}})">
<summary>
 Creates an alternative through which all the values of the stream
 generated after the point at which the alternative has been created can be
 read.  See also: `indefinitely`.
</summary>
</member>
<member name="M:Hopac.Stream.toSeq``1(Hopac.Alt{Hopac.Stream.Cons{``0}})">
<summary>
 Preliminary and subject to change.
</summary>
</member>
<member name="M:Hopac.Stream.afterTimeSpan(System.TimeSpan)">
<summary>
 Preliminary and subject to change.
</summary>
</member>
<member name="M:Hopac.Stream.atDateTimeOffset(System.DateTimeOffset)">
<summary>
 Preliminary and subject to change.
</summary>
</member>
<member name="M:Hopac.Stream.atDateTimeOffsets(Hopac.Alt{Hopac.Stream.Cons{System.DateTimeOffset}})">
<summary>
 Preliminary and subject to change.
</summary>
</member>
<member name="M:Hopac.Stream.beforeEach``2(Hopac.Job{``0},Hopac.Alt{Hopac.Stream.Cons{``1}})">
<summary>
 Returns a stream that runs the given job each time a value is requested
 before requesting the next value from the given stream.  If the given job
 fails, the returned stream also fails.
</summary>
</member>
<member name="M:Hopac.Stream.afterEach``2(Hopac.Job{``0},Hopac.Alt{Hopac.Stream.Cons{``1}})">
<summary>
 Returns a stream that produces the same elements as the given stream, but
 after each element, the given job is used as a delay before a request is
 made to the given stream for the next element.  If the given job fails,
 the returned stream also fails.
</summary>
</member>
<member name="M:Hopac.Stream.delayEach``2(Hopac.Job{``0},Hopac.Alt{Hopac.Stream.Cons{``1}})">
<summary>
 Returns a stream that produces the same elements as the given stream, but
 delays each pulled element using the given job.  If the given job fails,
 the returned stream also fails.  See also: `shift`.
</summary>
</member>
<member name="M:Hopac.Stream.shift``2(Hopac.Job{``0},Hopac.Alt{Hopac.Stream.Cons{``1}})">
<summary>
 Returns a stream that produces the same sequence of elements as the given
 stream, but shifted in time by the given timeout.
</summary>
</member>
<member name="M:Hopac.Stream.combineLatest``2(Hopac.Alt{Hopac.Stream.Cons{``0}},Hopac.Alt{Hopac.Stream.Cons{``1}})">
<summary>
 Returns a stream that produces a new pair of elements whenever either one
 of the given pair of streams produces an element.  If one of the streams
 produces multiple elements before any elements are produced by the other
 stream, then those elements are skipped.  See also: `zip`.
</summary>
</member>
<member name="M:Hopac.Stream.throttle``2(Hopac.Job{``0},Hopac.Alt{Hopac.Stream.Cons{``1}})">
<summary>
 Returns a stream that produces elements from the given stream so that
 after an element is produced by the given stream, a timeout is started and
 the latest element produced by the stream is produced when the timeout
 expires.  See also: `debounce`.
</summary>
</member>
<member name="M:Hopac.Stream.debounce``2(Hopac.Alt{``0},Hopac.Alt{Hopac.Stream.Cons{``1}})">
<summary>
 Returns a stream that produces elements from the given stream so that an
 element is produced after the given timeout unless a new element is
 produced by the given stream in which case the timeout is restarted.  Note
 that if the given stream produces elements more frequently than the
 timeout, the returned stream never produces any elements.  See also:
 `throttle`.
</summary>
</member>
<member name="M:Hopac.Stream.sample``2(Hopac.Alt{Hopac.Stream.Cons{``0}},Hopac.Alt{Hopac.Stream.Cons{``1}})">
<summary>
 `sample ticks elems` returns a stream that produces each `elem` that is
 followed by a `tick`.  Excess elements from both streams are skipped.  In
 other words, `elem` followed by `elem` and `tick` followed by `tick` is
 skipped.
</summary>
</member>
<member name="M:Hopac.Stream.onCloseFun``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit},Hopac.Alt{Hopac.Stream.Cons{``0}})">
<summary>
 `xs |&gt; onCloseFun u2u` is equivalent to `xs |&gt; onCloseJob (Job.thunk
 u2u)`.
</summary>
</member>
<member name="M:Hopac.Stream.onCloseJob``1(Hopac.Job{Microsoft.FSharp.Core.Unit},Hopac.Alt{Hopac.Stream.Cons{``0}})">
<summary>
 Returns a stream that is just like the given stream except that just
 before the returned stream is closed, due to the given stream being
 closed, whether with an error or without, the given job is executed.  In
 case the job raises an exception, that exception closes the returned
 stream.
</summary>
</member>
<member name="M:Hopac.Stream.catch``2(Microsoft.FSharp.Core.FSharpFunc{System.Exception,``0},Hopac.Alt{Hopac.Stream.Cons{``1}})">
<summary>
 Returns a stream that produces the same sequence of elements as the given
 stream.  If the given stream fails, a new stream is constructed by calling
 the given function and that stream becomes the remainder of the stream.
</summary>
</member>
<member name="M:Hopac.Stream.switchOn``1(Hopac.Alt{Hopac.Stream.Cons{``0}},Hopac.Alt{Hopac.Stream.Cons{``0}})">
<summary>
 Preliminary and subject to change.
</summary>
</member>
<member name="M:Hopac.Stream.takeUntil``2(Hopac.Alt{``0},Hopac.Alt{Hopac.Stream.Cons{``1}})">
<summary>
 Preliminary and subject to change.
</summary>
</member>
<member name="M:Hopac.Stream.skipUntil``2(Hopac.Alt{``0},Hopac.Alt{Hopac.Stream.Cons{``1}})">
<summary>
 Preliminary and subject to change.
</summary>
</member>
<member name="M:Hopac.Stream.take``1(System.Int64,Hopac.Alt{Hopac.Stream.Cons{``0}})">
<summary>
 `take n` returns a stream that has the first `n` elements of the given
 stream.  If the given stream is shorter than `n`, then `take n` is the
 identity function.  Note that if `n` is non-negative, then `append (take n
 xs) (skip n xs)` is equivalent to `xs`.
</summary>
</member>
<member name="M:Hopac.Stream.skip``1(System.Int64,Hopac.Alt{Hopac.Stream.Cons{``0}})">
<summary>
 `skip n xs` returns a stream without the first `n` elements of the given
 stream.  If the given stream is shorter than `n`, then the returned stream
 will be empty.  Note that if `n` is non-negative, then `append (take n xs)
 (skip n xs)` is equivalent to `xs`.
</summary>
</member>
<member name="M:Hopac.Stream.switchMap``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Hopac.Alt{Hopac.Stream.Cons{``0}})">
<summary>
 Maps and joins all the streams together with `switch`.  This is perhaps
 the most useful binding form with choice streams as this correspond to the
 idea of producing results based only on the latest source of information.
</summary>
</member>
<member name="M:Hopac.Stream.appendMap``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Hopac.Alt{Hopac.Stream.Cons{``0}})">
<summary>
 Maps and joins all the streams together with `append`.  This is roughly
 the same function as `Seq.collect`, but is probably less frequently used
 with choice streams.
</summary>
</member>
<member name="M:Hopac.Stream.mergeMap``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Hopac.Alt{Hopac.Stream.Cons{``0}})">
<summary>
 Maps and joins all the streams together with `merge`.  This corresponds to
 interleaving results based on all sources of information.  While this is a
 theoretically important combinator, `mergeMap` is probably not the most
 useful binding form on choice streams.
</summary>
</member>
<member name="M:Hopac.Stream.ambMap``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Hopac.Alt{Hopac.Stream.Cons{``0}})">
<summary>
 Maps and joins all the streams together with `amb`.  This corresponds to
 the idea of starting several alternative streams in parallel and then only
 using the one that produces the first result.
</summary>
</member>
<member name="M:Hopac.Stream.mapJoin``5(Microsoft.FSharp.Core.FSharpFunc{Hopac.Alt{Hopac.Stream.Cons{``0}},Microsoft.FSharp.Core.FSharpFunc{Hopac.Alt{Hopac.Stream.Cons{``1}},``2}},Microsoft.FSharp.Core.FSharpFunc{``3,``4},Hopac.Alt{Hopac.Stream.Cons{``3}})">
<summary>
 `mapJoin j f xs` is equivalent to `joinWith j (mapFun f xs)`.
</summary>
</member>
<member name="M:Hopac.Stream.joinWith``4(Microsoft.FSharp.Core.FSharpFunc{Hopac.Alt{Hopac.Stream.Cons{``0}},Microsoft.FSharp.Core.FSharpFunc{Hopac.Alt{Hopac.Stream.Cons{``1}},``2}},Hopac.Alt{Hopac.Stream.Cons{``3}})">
<summary>
 Joins all the streams in the given stream of streams together with the
 given binary join combinator.
</summary>
</member>
<member name="M:Hopac.Stream.switch``1(Hopac.Alt{Hopac.Stream.Cons{``0}},Hopac.Alt{Hopac.Stream.Cons{``0}})">
<summary>
 Returns a stream that produces elements from the first stream as long as
 the second stream produces no elements.  As soon as the second stream
 produces an element, the returned stream only produces elements from the
 second stream.  See also: `switchMap`.
</summary>
</member>
<member name="M:Hopac.Stream.append``1(Hopac.Alt{Hopac.Stream.Cons{``0}},Hopac.Alt{Hopac.Stream.Cons{``0}})">
<summary>
 Concatenates the given two streams.  In other words, returns a stream that
 first produces all the elements from first stream and then all the
 elements from the second stream.  If the first stream is infinite, no
 elements are produced from the second stream.  See also: `appendMap`.
</summary>
</member>
<member name="M:Hopac.Stream.merge``1(Hopac.Alt{Hopac.Stream.Cons{``0}},Hopac.Alt{Hopac.Stream.Cons{``0}})">
<summary>
 Returns a stream that produces elements from both of the given streams so
 that elements from the streams are interleaved non-deterministically in
 the returned stream.  See also: `mergeMap`.
</summary>
</member>
<member name="M:Hopac.Stream.amb``1(Hopac.Alt{Hopac.Stream.Cons{``0}},Hopac.Alt{Hopac.Stream.Cons{``0}})">
<summary>
 Of the two given streams, returns the stream that first produces an
 element.  See also: `ambMap`.
</summary>
</member>
<member name="M:Hopac.Stream.distinctUntilChanged``1(Hopac.Alt{Hopac.Stream.Cons{``0}})">
<summary>
 Preliminary and subject to change.
</summary>
</member>
<member name="M:Hopac.Stream.distinctUntilChangedByFun``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Hopac.Alt{Hopac.Stream.Cons{``0}})">
<summary>
 Preliminary and subject to change.
</summary>
</member>
<member name="M:Hopac.Stream.distinctUntilChangedByJob``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Hopac.Alt{Hopac.Stream.Cons{``0}})">
<summary>
 Preliminary and subject to change.
</summary>
</member>
<member name="M:Hopac.Stream.distinctUntilChangedWithFun``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean}},Hopac.Alt{Hopac.Stream.Cons{``0}})">
<summary>
 Preliminary and subject to change.
</summary>
</member>
<member name="M:Hopac.Stream.distinctUntilChangedWithJob``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},Hopac.Alt{Hopac.Stream.Cons{``0}})">
<summary>
 Preliminary and subject to change.
</summary>
</member>
<member name="M:Hopac.Stream.distinctByFun``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Hopac.Alt{Hopac.Stream.Cons{``0}})">
<summary>
 Preliminary and subject to change.
</summary>
</member>
<member name="M:Hopac.Stream.distinctByJob``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Hopac.Alt{Hopac.Stream.Cons{``0}})">
<summary>
 Preliminary and subject to change.
</summary>
</member>
<member name="M:Hopac.Stream.scanFromFun``2(``0,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},Hopac.Alt{Hopac.Stream.Cons{``1}})">
<summary>
 `scanFromFun s sx2sJ xs` is equivalent to `scanFun sx2sJ s xs` and is
 often syntactically more convenient to use.
</summary>
</member>
<member name="M:Hopac.Stream.scanFromJob``3(``0,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Hopac.Alt{Hopac.Stream.Cons{``1}})">
<summary>
 `scanFromJob s sx2sJ xs` is equivalent to `scanJob sx2sJ s xs` and is
 often syntactically more convenient to use.
</summary>
</member>
<member name="M:Hopac.Stream.scanFun``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,Hopac.Alt{Hopac.Stream.Cons{``1}})">
<summary>
 Preliminary and subject to change.
</summary>
</member>
<member name="M:Hopac.Stream.scanJob``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``0,Hopac.Alt{Hopac.Stream.Cons{``1}})">
<summary>
 Preliminary and subject to change.
</summary>
</member>
<member name="M:Hopac.Stream.zip``2(Hopac.Alt{Hopac.Stream.Cons{``0}},Hopac.Alt{Hopac.Stream.Cons{``1}})">
<summary>
 Returns a stream of pairs of elements from the given pair of streams.  No
 elements from either stream are skipped and each element is used only
 once.  See also: `combineLatest`.
</summary>
</member>
<member name="M:Hopac.Stream.groupByFun``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Hopac.Alt{Hopac.Stream.Cons{``0}})">
<summary>
 Splits the given stream into substreams based on the keys extracted from
 the elements by the given function.  See `groupByJob` for further details.
</summary>
</member>
<member name="M:Hopac.Stream.groupByJob``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Hopac.Alt{Hopac.Stream.Cons{``0}})">
<summary>
 Splits the given stream into substreams based on the keys extracted from
 the elements by the given job.  See also: `groupByFun`.
</summary>
</member>
<member name="M:Hopac.Stream.mapFun``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Hopac.Alt{Hopac.Stream.Cons{``0}})">
<summary>
 Returns a stream that produces elements passed through the given function
 whenever the given streams produces elements.
</summary>
</member>
<member name="M:Hopac.Stream.mapJob``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Hopac.Alt{Hopac.Stream.Cons{``0}})">
<summary>
 Returns a stream that produces elements passed through the given job
 whenever the given streams produces elements.

 Reference implementation:

&gt; let rec mapJob x2yJ xs =
&gt;   memo (xs &gt;&gt;= function Nil -&gt; nil
&gt;                       | Cons (x, xs) -&gt;
&gt;                         x2yJ x |&gt;&gt;? fun y -&gt; Cons (y, mapJob x2yJ xs))

 Above, `memo` is `fun x -&gt; Promise.Now.delay x :&gt; Alt&lt;_&gt;`.
</summary>
</member>
<member name="M:Hopac.Stream.filterFun``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Hopac.Alt{Hopac.Stream.Cons{``0}})">
<summary>
 Returns a stream that contains the elements from the given stream for
 which the given function returns `true`.
</summary>
</member>
<member name="M:Hopac.Stream.filterJob``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Hopac.Alt{Hopac.Stream.Cons{``0}})">
<summary>
 Returns a stream that contains the elements from the given stream for
 which the given job returns `true`.
</summary>
</member>
<member name="M:Hopac.Stream.choose``1(Hopac.Alt{Hopac.Stream.Cons{Microsoft.FSharp.Core.FSharpOption{``0}}})">
<summary>
 `xs |&gt; choose` is equivalent to `xs |&gt; chooseFun id`.
</summary>
</member>
<member name="M:Hopac.Stream.chooseFun``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Hopac.Alt{Hopac.Stream.Cons{``0}})">
<summary>
 Returns a stream that produces results whenever the given stream produces
 an element and the given function returns `Some` result from that element.
</summary>
</member>
<member name="M:Hopac.Stream.chooseJob``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Hopac.Alt{Hopac.Stream.Cons{``0}})">
<summary>
 Returns a stream that produces results whenever the given stream produces
 an element and the given job returns `Some` result from that element.
</summary>
</member>
<member name="M:Hopac.Stream.toObservable``1(Hopac.Alt{Hopac.Stream.Cons{``0}})">
<summary>
 Returns observable that eagerly consumes the stream
</summary>
</member>
<member name="M:Hopac.Stream.subscribingTo``3(System.IObservable{``0},Microsoft.FSharp.Core.FSharpFunc{Hopac.Alt{Hopac.Stream.Cons{``0}},``1})">
<summary>
 Preliminary and subject to change.
</summary>
</member>
<member name="M:Hopac.Stream.subscribeDuring``3(Microsoft.FSharp.Core.FSharpFunc{Hopac.Alt{Hopac.Stream.Cons{``0}},``1},System.IObservable{``0})">
<summary>
 Creates a stream, using the given function, that subscribes to the
 observable when the first element of the stream is requested and
 unsubscribes from the observable when the returned stream closes.  See
 also: `subscribeOnFirst`.
</summary>
</member>
<member name="M:Hopac.Stream.subscribeOnFirst``1(System.IObservable{``0})">
<summary>
 Creates a stream that subscribes to the observable when the first element
 of the stream is requested.  Conversely, if no elements are requested from
 the returned stream, no subscribe action is performed.  There is no way to
 explicitly unsubscribe.  To limit the subscription, you need to compose
 the observable in such a way that it is closed at the point when it needs
 to be unsubscribed.  See also: `subscribeDuring`.
</summary>
</member>
<member name="M:Hopac.Stream.cycle``1(Hopac.Alt{Hopac.Stream.Cons{``0}})">
<summary>
 Creates an infinite repetition of the given stream.  For infinite streams
 `cycle` is the identity function.
</summary>
</member>
<member name="M:Hopac.Stream.repeat``1(``0)">
<summary>
 Creates an infinite stream of the given value.
</summary>
</member>
<member name="M:Hopac.Stream.iterateFun``1(Microsoft.FSharp.Core.FSharpFunc{``0,``0},``0)">
<summary>
 Preliminary and subject to change.
</summary>
</member>
<member name="M:Hopac.Stream.iterateJob``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0)">
<summary>
 Preliminary and subject to change.
</summary>
</member>
<member name="M:Hopac.Stream.unfoldFun``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{System.Tuple{``1,``0}}},``0)">
<summary>
 Preliminary and subject to change.
</summary>
</member>
<member name="M:Hopac.Stream.unfoldJob``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0)">
<summary>
 Preliminary and subject to change.
</summary>
</member>
<member name="M:Hopac.Stream.once``1(Hopac.Job{``0})">
<summary>
 `once xJ` is equivalent to `indefinitely xJ |&gt; take 1`.
</summary>
</member>
<member name="M:Hopac.Stream.indefinitely``1(Hopac.Job{``0})">
<summary>
 Generates a stream by repeating the given job indefinitely.  For example,
 given a channel, `xCh`, a stream can be created, `indefinitely xCh`,
 through which all the values given on the channel can be observed.  See
 also: `values`.
</summary>
</member>
<member name="M:Hopac.Stream.ofSeq``1(System.Collections.Generic.IEnumerable{``0})">
<summary>
 Converts the given sequence to a lazy stream.
</summary>
</member>
<member name="M:Hopac.Stream.one``1(``0)">
<summary>
 `one x` is equivalent to `cons x nil`.
</summary>
</member>
<member name="M:Hopac.Stream.error``1(System.Exception)">
<summary>
 Constructs a choice stream that is closed with an error.
</summary>
</member>
<member name="M:Hopac.Stream.never``1">
<summary>
 A choice stream that never produces any values and never closes.
</summary>
</member>
<member name="M:Hopac.Stream.delay``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 `delay` creates a stream that is constructed lazily.  Use `delay` to avoid
 unbounded eager recursion.
</summary>
</member>
<member name="M:Hopac.Stream.cons``1(``0,Hopac.Alt{Hopac.Stream.Cons{``0}})">
<summary>
 `cons x xs` constructs a choice stream whose first value is `x` and the
 rest of the stream is like `xs`.
</summary>
</member>
<member name="M:Hopac.Stream.nil``1">
<summary>
 An empty or closed choice stream.
</summary>
</member>
<member name="M:Hopac.Stream.Var.tap``1(Hopac.Stream.Var{``0})">
<summary>
 Returns the generated stream, including the current value of the
 variable, from the point in time when `tap` is called.
</summary>
</member>
<member name="M:Hopac.Stream.Var.set``1(Hopac.Stream.Var{``0},``0)">
<summary>
 Sets the value of the variable and appends the value to the end of the
 generated stream.  Note that while this operation is atomic, and can be
 safely used from multiple parallel jobs, a combination of `get` and
 `set` is not atomic.
</summary>
</member>
<member name="M:Hopac.Stream.Var.get``1(Hopac.Stream.Var{``0})">
<summary>
 Gets the value of the variable.
</summary>
</member>
<member name="M:Hopac.Stream.Var.create``1(``0)">
<summary>
 Creates a new stream variable.
</summary>
</member>
<member name="T:Hopac.Stream.Var">
<summary>
 Operations on stream variables.
</summary>
</member>
<member name="M:Hopac.Stream.Src.tap``1(Hopac.Stream.Src{``0})">
<summary>
 Returns the remainder of the generated stream after the point in time
 when `tap` is called.
</summary>
</member>
<member name="M:Hopac.Stream.Src.close``1(Hopac.Stream.Src{``0})">
<summary>
 Terminates the stream.
</summary>
</member>
<member name="M:Hopac.Stream.Src.error``1(Hopac.Stream.Src{``0},System.Exception)">
<summary>
 Terminates the stream with an error.  The given exception is raised in
 the consumers of the stream if and when they reach the end of the
 stream.
</summary>
</member>
<member name="M:Hopac.Stream.Src.value``1(Hopac.Stream.Src{``0},``0)">
<summary>
 Appends a new value to the end of the generated stream.  This operation
 is atomic and non-blocking and can be safely used from multiple parallel
 jobs.
</summary>
</member>
<member name="M:Hopac.Stream.Src.create``1">
<summary>
 Creates a new stream source.
</summary>
</member>
<member name="T:Hopac.Stream.Src">
<summary>
 Operations on stream sources.
</summary>
</member>
<member name="T:Hopac.Stream">
<summary>
 Operations on choice streams.
</summary>
</member>
<member name="M:Hopac.Timer.Global.timeOutMillis(System.Int32)">
<summary>
 `timeOutMillis n` is equivalent to `timeOut (TimeSpan.FromMilliseconds
 (float n))`.
</summary>
</member>
<member name="M:Hopac.Timer.Global.timeOut(System.TimeSpan)">
<summary>
 Creates an alternative that, after instantiation, becomes available
 after the specified time span.

 Note that this is simply not intended for high precision timing and the
 resolution of the underlying timing mechanism is very coarse (Windows
 system ticks).

 Note that you do not need to create a new timeout alternative every time
 you need a timeout with a specific time span.
</summary>
</member>
<member name="T:Hopac.Timer.Global">
<summary>
 Operations on the global wall-clock timer.  The global timer is implicitly
 associated with the global scheduler.
</summary>
</member>
<member name="T:Hopac.Timer">
<summary>
 Operations on a wall-clock timer.
</summary>
</member>
<member name="T:Hopac.TopLevel.Stream`1">
<summary>
 Represents a non-deterministic stream of values called a choice stream.
</summary>
</member>
<member name="M:Hopac.TopLevel.timeOutMillis(System.Int32)">
<summary>
 Creates a timeout for the specified number of milliseconds.  This is the
 same function as `Timer.Global.timeOutMillis`.
</summary>
</member>
<member name="M:Hopac.TopLevel.timeOut(System.TimeSpan)">
<summary>
 Creates a timeout for the specified time span.  This is the same function
 as `Timer.Global.timeOut`.
</summary>
</member>
<member name="M:Hopac.TopLevel.mvarFull``1(``0)">
<summary>
 Creates a new serialized variable that initially contains the given value.
 This is the same function as `MVar.Now.createFull`.
</summary>
</member>
<member name="M:Hopac.TopLevel.mvar``1">
<summary>
 Creates a serialized variable that is initially empty.  This is the same
 function as `MVar.Now.create`.
</summary>
</member>
<member name="M:Hopac.TopLevel.ivarFull``1(``0)">
<summary>
 Creates a new write once variable with the given value.  This is the same
 function as `IVar.Now.createFull`.
</summary>
</member>
<member name="M:Hopac.TopLevel.ivar``1">
<summary>
 Creates a new write once variable.  This is the same function as
 `IVar.Now.create`.
</summary>
</member>
<member name="M:Hopac.TopLevel.mb``1">
<summary>
 Creates a new mailbox.  This is the same function as
 `Mailbox.Now.create`.
</summary>
</member>
<member name="M:Hopac.TopLevel.ch``1">
<summary>
 Creates a new channel.  This is the same function as `Ch.Now.create`.
</summary>
</member>
<member name="M:Hopac.TopLevel.asJob``1(Hopac.Job{``0})">
<summary>
 Use object as job.  This function is a NOP and is provided as a kind of
 syntactic alternative to using a type ascription or an `upcast`.
</summary>
</member>
<member name="M:Hopac.TopLevel.asAlt``1(Hopac.Alt{``0})">
<summary>
 Use object as alternative.  This function is a NOP and is provided as a
 kind of syntactic alternative to using a type ascription or an `upcast`.
</summary>
</member>
<member name="M:Hopac.TopLevel.server(Hopac.Job{Hopac.Void})">
<summary>
 Like `start`, but the given job is known never to return normally, so the
 job can be spawned in an even more lightweight manner.

 Note that using this function in a job workflow is not optimal and you
 should use `Job.server` instead.

 This is the same function as `Job.Global.server`.
</summary>
</member>
<member name="M:Hopac.TopLevel.queueIgnore``1(Hopac.Job{``0})">
<summary>
 `queueIgnore xJ` is equivalent to `Job.Ignore xJ |&gt; queue`.
</summary>
</member>
<member name="M:Hopac.TopLevel.queue(Hopac.Job{Microsoft.FSharp.Core.Unit})">
<summary>
 Queues the given job for execution on the global scheduler.

 Note that using this function in a job workflow is not optimal and you
 should use `Job.queue` instead.

 This is the same function as `Job.Global.queue`.
</summary>
</member>
<member name="M:Hopac.TopLevel.startIgnore``1(Hopac.Job{``0})">
<summary>
 `startIgnore xJ` is equivalent to `Job.Ignore xJ |&gt; start`.
</summary>
</member>
<member name="M:Hopac.TopLevel.start(Hopac.Job{Microsoft.FSharp.Core.Unit})">
<summary>
 Starts running the given job on the global scheduler, but does not wait
 for the job to finish.

 Note that using this function in a job workflow is not optimal and you
 should use `Job.start` instead.

 This is the same function as `Job.Global.start`.
</summary>
</member>
<member name="M:Hopac.TopLevel.run``1(Hopac.Job{``0})">
<summary>
 Starts running the given job on the global scheduler and then blocks the
 current thread waiting for the job to either return successfully or fail.
</summary>
</member>
<member name="P:Hopac.TopLevel.job">
<summary>
 Default expression builder for jobs.
</summary>
</member>
<member name="T:Hopac.TopLevel">
<summary>
 Convenience bindings for programming with Hopac.
</summary>
</member>
<member name="">

</member>
<member name="T:System.AssemblyVersionInformation">

</member>
</members>
</doc>
